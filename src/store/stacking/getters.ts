import { notify } from "@kyvg/vue3-notification";
import { StackingState } from "../../types/stacking";
import { dollarsValue } from "../../utils";

/**
 * @notice used to compute the name of the blocks for the FSA graph
 */
export function blockNames(state: StackingState): string[] {
  return state.public.stacks.map(({ slot, amount }) => `block ${slot}`);
}

/**
 * @notice used to compute the amounts of the blocks for the FSA graph
 */
export function blockAmounts(state: StackingState): number[] {
  return state.public.stacks.map(({ slot, amount }) => amount);
}

/**
 * @notice used to compute the top 5 tokens FSA for the last block
 */
export function top5FeesLastBlock(
  state: StackingState
): { name: string; value: number }[] {
  const sortedArray = state.public.fees[state.public.fees.length - 1].fees
    .toSorted((first, second) => {
      return second.amount - first.amount;
    })
    .slice(0, 5);
  return sortedArray.map(({ token, amount }) => {
    return { name: token, value: amount };
  });
}

/**
 * @notice used to compute the top 5 tokens FSA since the beginning
 */
export function top5FeesAllTime(
  state: StackingState
): { name: string; value: number }[] {
  const tokens: { [key in string]: number } = {};

  state.public.fees.forEach(({ slot, fees }) => {
    fees.forEach(({ token, amount }) => {
      if (token in tokens) {
        tokens[token] += amount;
      } else {
        tokens[token] = amount;
      }
    });
  });
  return Object.entries(tokens)
    .map(([name, value]) => ({ name, value }))
    .sort((a, b) => b.value - a.value)
    .slice(0, 5);
}

/**
 * @notice used to compute the user percent of stacking
 */
export function userStackingShare(state: StackingState): number {
  if (!state.public.stacks.length) return 0;
  if (!state.user.stacks.length) return 0;
  return (
    Math.round(
      (10000 * state.user.stacks[state.user.stacks.length - 1].amount) /
        state.public.stacks[state.public.stacks.length - 1].amount
    ) / 10000
  );
}

/**
 * @notice - used to compute a stacking object from the user stacks
 * @param state - the stacking state
 * @returns - the computed stack object
 */
export function userStacksObject(state: StackingState): {
  [key in number]: number;
} {
  let result: { [key in number]: number } = {};

  for (const { amount, slot } of state.user.stacks) {
    result[slot] = amount;
  }
  return result;
}

/**
 * @notice - used to compute a fees withdrawal object from the user withdrawals
 * @param state - the stacking state
 * @returns - the computed withdrawals object
 */
export function userFeesWithdrawalObject(state: StackingState): {
  [key in number]: number;
} {
  let result: { [key in string]: number } = {};

  for (const { tokens, slot } of state.user.feesWithdrawal) {
    for (const token of tokens) {
      if (!result[token] || result[token] < slot) result[token] = slot;
    }
  }
  return result;
}

/**
 * @notice - used to compute a stacking object from the public stacks
 * @param state - the stacking state
 * @returns - the computed stack object
 */
export function publicStacksObject(state: StackingState): {
  [key in number]: number;
} {
  let result: { [key in number]: number } = {};

  for (const { amount, slot } of state.public.stacks) {
    result[slot] = amount;
  }
  return result;
}

/**
 * @notice - used to compute a fees object from the public fees
 * @param state - the stacking state
 * @returns - the computed fees object
 */
export function publicFeesObject(state: StackingState): {
  [key in number]: Array<{ token: string; amount: number }>;
} {
  let result: { [key in number]: Array<{ token: string; amount: number }> } =
    {};

  for (const { fees, slot } of state.public.fees) {
    result[slot] = fees;
  }
  return result;
}

/**
 *
 * @param publicStacks - the public stack objects
 * @param userStacks - the user stack object
 * @param globalFees - the global fees object
 * @returns - the object containing the fsa generated by the user stackings so far
 */
export function computeUserGlobalFSA(
  publicStacks: { [key in number]: number },
  userStacks: { [key in number]: number },
  globalFees: { [key in number]: Array<{ token: string; amount: number }> }
): { [key in string]: number } {
  let result: { [key in string]: number } = {};
  let userStakedAmount = 0;
  let publicStakedAmount = 0;

  const userSlots = Object.keys(userStacks).map((value) => Number(value));
  const minSlot = Math.min(...userSlots);
  const maxSlot = Math.max(
    ...Object.keys(globalFees).map((value) => Number(value))
  );

  try {
    for (let slot = minSlot; slot <= maxSlot; ++slot) {
      if (userStacks[slot]) userStakedAmount = userStacks[slot];
      if (publicStacks[slot]) publicStakedAmount = publicStacks[slot];
      if (slot == minSlot) continue;
      if (!globalFees[slot]) continue;

      const percent = userStakedAmount / publicStakedAmount;
      globalFees[slot].forEach(({ token, amount }) => {
        if (!result[token]) result[token] = 0;
        result[token] += percent * amount;
      });
    }
  } catch (e: any) {
    console.log(e);
    notify({
      text: "An error occured for FSA calulation check console",
      type: "warn",
    });
  }
  return result;
}

/**
 *
 * @param publicStacks - the public stack objects
 * @param userStacks - the user stack object
 * @param userFeesWithdrawal - the user stack object
 * @param globalFees - the global fees object
 * @returns - the object containing the fsa available for the user
 */
export function computeUserAvailableFSA(
  publicStacks: { [key in number]: number },
  userStacks: { [key in number]: number },
  userFeesWithdrawal: { [key in string]: number },
  globalFees: { [key in number]: Array<{ token: string; amount: number }> }
): {
  [key in string]: {
    amount: number;
    dollarsValue: number;
    lastWithdraw: number;
  };
} {
  let result: {
    [key in string]: {
      amount: number;
      dollarsValue: number;
      lastWithdraw: number;
    };
  } = {};
  let userStakedAmount = 0;
  let publicStakedAmount = 0;

  const userSlots = Object.keys(userStacks).map((value) => Number(value));
  const minSlot = Math.min(...userSlots);
  const maxSlot = Math.max(
    ...Object.keys(globalFees).map((value) => Number(value))
  );

  try {
    for (let slot = minSlot; slot <= maxSlot; ++slot) {
      if (userStacks[slot]) userStakedAmount = userStacks[slot];
      if (publicStacks[slot]) publicStakedAmount = publicStacks[slot];
      if (slot == minSlot) continue;
      if (!globalFees[slot]) continue;

      const percent = userStakedAmount / publicStakedAmount;
      globalFees[slot].forEach(({ token, amount }) => {
        if (!result[token])
          result[token] = { amount: 0, lastWithdraw: 0, dollarsValue: 0 };
        if (userFeesWithdrawal[token] && userFeesWithdrawal[token] >= slot) {
          result[token].lastWithdraw = userFeesWithdrawal[token];
        } else {
          result[token].amount += percent * amount;
          result[token].dollarsValue = dollarsValue({
            [token]: result[token].amount,
          });
          if (userFeesWithdrawal[token])
            result[token].lastWithdraw = userFeesWithdrawal[token];
        }
      });
    }
    for (const token in result) {
      if (!result[token].amount) delete result[token];
    }
  } catch (e: any) {
    console.log(e);
    notify({
      text: "An error occured for FSA calulation check console",
      type: "warn",
    });
  }
  return result;
}
